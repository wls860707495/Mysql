# 数据查询 
## 查询/更新流程
### 查询
```
连接器 ->(是否有缓存，有则走缓存，没有则下一步) -> 分析器(这一步也判断有无缓存) -> 优化器  -> 执行器 -> 存储引擎        

连接器：此处最好使用长连接，在查询频繁时短链接总是挂掉会影响查询效率。长连接使用容易出现内存爆满问题，此时最好设置一个长连接的断开时间。        

分析器：进行词法与语法的分析，在分析时指出语法错误。        

优化器：优化器进行优化，比如在join时索引的选择是如何做的，在进行语句查询的先后顺序又是什么。        

执行器：进行语句的执行，此前先进行的是权限的判断，然后会根据有无索引进行相应的接口调用  
```
### 更新
```
    上述为查询时的流程，但在更新时，因为每次表的更新导致缓存不能使用，此时无缓存这一步。同时，当mysql任务繁忙时，为了解决更新这一问题，引入了Write-Ahead Logging（WAL技术，即先考虑将更新记录存入日志中，然后等myql空闲时将更新存入磁盘）。

     其中的核心为：redo log（引擎层-Innodb有的日志）以及bin log（server层有的日志）两种日志。

redo log：呈环状，其中有一个write pos 以及 checkpoint ，write pos及记录的起始，需要更新的记录从此处开始。checkpoint则是要更新到磁盘的起始点，更新一部分磁盘后讲redo log的这一部分占用空间删除。当write pos追上checkpoint时，代表无空闲日志空间，此时write pos必须停下记录。先将checkpoint开始的记录存入磁盘一部分再开始启用。

    bin log：bin log与redo log不同，bin log是server层的，也就是说他可以在任何存储引擎执行完后使用。redo log则是innodb引擎专有的。除此之外的不同是redo log存的是哪个物理页需要修改啥数据，binlog则是存储逻辑修改，即set c = c + 1 where ID = 10(给id =10的这一行的c字段+1)。恢复库或者搭建备用库时需要的就是全量备份+binlog日志来实现。

当我们进行更新操作时，以使用innodb引擎为例，执行器的执行阶段大概可分为以下几个：

执行器调用引擎查找ID=10的这一行（内存有则直接取，没有则从磁盘调入内存） ->  执行器进行c+1 并再次调用引擎存入内存 -> innodb引擎中此时redo log处于prepare状态，并记录此时的值 -> 此次操作的行为存入binlog -> redo log改为commit状态 （redo log的两次状态被称为两段提交）

为何使用两阶段提交（即先redo log prepare -> bin log 记录 -> redo log commit）？

在进行如果不将redo log分两个状态在bin log两边提交，先进行redo log 或者先进行binlog时，出现mysql重启，就会导致恢复数据不一致问题。
```

## 事务
### 隔离性与隔离级别
```
隔离性分为四种：未提交读/提交读/可重复读/串行化，四种级别逐级提高。下面以两个事务对同一行数据进行操作，同时查与读为例。

未提交读：在修改未进行提交时便可以读，此时会出现将刚刚修改过但未提交的行数据读取，出现读取不一致情况

提交读：提交后才能读，但读事务若是读两次的话，会出现读事务提交前两次读取不一致的情况。（使用视图，视图在sql语句开始执行时创建）

    可重复读：可以保证在一个事务读取前后读取内容是一致的。（使用视图，视图在事务启动时创建，整个事务过程中一直存在，并且保持不变）

    可串行化：使用锁来实现串行化。

事务如何实现隔离，事务实现隔离使用的是多版本并发控制mvcc，对于每个事务开始时都会创建一个read-view，再可重复读的隔离级别下，每个事务对同一条数据有自己的视图（read-view），最新的数据可以通过回滚回滚到之前的read-view。当然长事务会导致视图一直存在占用资源。mysql会删除不需要的回滚日志。
```

### 有关mvcc
```
mvcc多版本并发控制是主要为了解决读写冲突实现的。只是使用悲观锁会比较臃肿。对于每一条数据，都会有隐藏的自增键、DB_trx_id(最后一次修改这个数据的事务id)以及undo指针

当进行一个select操作的时候，如何判断当前事务的可见性呢。当我们创建事务时会创建相应的read view视图。事务对数据进行操作时会产生相应的undo日志，undo log是以链表形式存在，最终的头便是最新数据。创建read view视图时，read view会维护一个列表trx_list,其中会有min db_trx_id,也会有max db_trx_id+1。我们判断当前事务可以读到哪步数据时，是通过db_trx_id（db_trx_id是数据最新存储的事务id）与read view的trx_list比较得来的。三种情况：

1、db_trx_id <  min,此时db_trx_id前的版本都可以看见，若是>则进行第二步 

2、db_trx_id > max,证明不可见，若<则继续进行下一步 

3、查看db_trx_id是否在trx_list中，在trx_list中时说明read view生成时刻事务未commit，则不可见。不在说明已经commit，则可见(这是因为trx_list并不是一个连续序列，可能其中一部分事务id处在这个区间但是并不是活跃事务)。

如果三个条件都不满足，则db_trx_id则会变为undo log中的最新的db_trx_id，再根据这个规则去寻找，直至找到一个最新的可见的事务版本数据。
```
## 索引
### 介绍
```
数据库不同的引擎有着不同的索引，根据不同的场景有不同的使用常见的有几种：

哈希索引：适用于等值查询，但是范围查询效率会比较低；

有序数组索引：适用于静态引擎的查询。因为有序数组的查询效率很高，但是更新效率低下；

树：树用于索引要注意叶子结点的选择，当叶子结点过于少时，访问磁盘次数过多，会导致交互时间变长。

Innodb引擎：在Innodb引擎中，一张表的建立，添加字段索引后，索引分为两种

1、主键索引：主键索引以主键值为B+树建立索引，其中的叶子结点为相对应主键的一行数据。

2、普通索引：普通字段索引，索引设立为普通字段值的B+树，其中的叶子结点为主键的值。

当我们以普通索引列做索引时，会先查找普通索引，找到对应的主键值，再去进行主键索引，也被称为回表。
```

### 索引维护  
```
索引也需要维护，当我们B+树中的叶子结点到达相应大小时，会进行分裂，此时效率大概降低50%；同样的当叶子结点存储数据量<相应设置值时会进行叶子结点合并，此时会提高利用率

    是否使用自增主键，要根据具体的业务场景，主要要考虑空间问题。
```
### 索引优化
```
覆盖索引：联合索引的使用，当需要select的值在普通索引列可以找到时，此时不需要回表，被称为覆盖索引；在联合索引（a，b）中，B+树的节点存储总会是以a的顺序来存，那么我们可以不用单独维护(a)索引，只需维护（a，b）就可以了，同时当涉及到单个(b)、(c)索引时如何选择联合索引，这时根据b、c字段的占用空间来考虑。
```

###  索引下推
```
以(a, b)索引为例，mysql5.6以前，查找完a条件后会直接回表遍历主键索引。而5.6以后如果查询中包含b条件则会进行下推，不符合b条件的直接不回表。
```

### 唯一索引与普通索引
```
----------------------------------------------------------------------------------------------------------------------------	
                                在内存中（数据页）                       不在内存中（数据页）

唯一索引. 查询.       当数据页在内存中时，直接读数据页，找到相应值查询          当不再内存中时，会将数据页读到内存，并进行查询

        更新.        直接找到对应位置，判断是否存在，是唯一则修改             将涉及到的数据页放入内存，然后判断唯一并修改

普通索引. 查询        在内存中直接查询，找到当前需要值后寻找下一个非此值.        当不再内存中时，会将数据页读到内存，并进行查询
        更新.        直接找到对应位置并修改                                使用buffer pool的change buffer，修改时速度会比唯一索引快
----------------------------------------------------------------------------------------------------------------------------

change buffer：使用的是buffer pool的内存，数据库中可以设置buffer pool大小，命令为innodb_change_buffer_max_size

在普通索引修改不在内存中的数据页时，首先会将数据存入changebuffer来保证速率。change buffer也会更新，有两种方式：一种是进行查询时，将changebuffer merge入数据页，并存入内存查询；第二种是

数据库会支持后台线程将changebuffer数据merge入数据页。

change buffer 与 WAL的redo log：change buffer 是用于在更新时将数据先缓存，主要减少随机读磁盘IO消耗；对于WAL的redo log主要用于change buffer之后，change buffer完后数据会写入redo log。其中redo log主要用于减少随机写IO的消耗（会顺序写入）。
```

### 索引选择错误的解决方案
```
analyze table命令重新分析；force index()强制加索引或者更改sql语意来引导sql优化器的选择；在业务不需要的情况下直接删除索引。
```

## 锁
### 全局锁
```
Flush table with read lock（FTWRL）、-single-transaction(可重复隔离级别下自带备份工具)、set global readonly = true
----------------------------------------------------------------------------------------------------------------------------
方式.                             作用.                   异常处理机制                        应用引擎

FTWRL.                           全库逻辑备份.             出现异常时会解除全局锁.               mylSAM等不支持事务的引擎可用

-single-transaction.             全库逻辑备份.             有redo log以及bin log日志做恢复.     Innodb等支持事务的引擎

set global readonly = true.      判断主从库、全库逻辑备份.   出现异常时任会加锁，会导致服务不可用.   各类，但一般不用于全库逻辑备份
----------------------------------------------------------------------------------------------------------------------------
```

### 表级锁
```
    lock tables(通常的表锁)、MDL（metadata lock，元数据锁）

lock tables：通常在行级锁没用时才会被加上使用

MDL：一般进行表的访问及修改时时，会隐式进行锁的添加。一般对表的操作有两种：DML（对表的增删改查）、DDL（对表结构的更改）。DML时一般加MDL读锁，DDL一般加写锁。

注：当多条语句进行时，MDL会形成一个队列，并且写锁优于读锁，同时读写锁相互堵塞，读读不互堵。其中mysql进行DDL时一般分五步，拿MDL写锁 -> 降级为读锁 -> 开辟一块内存空间进行DDL -> 升级为写锁 -> 释放MDL写锁
```
### 行锁
```
行锁遵循两段锁协议，即在Innodb中，行锁在需要时加上，不需要时会在事务结束时才释放。在进行事务锁多行时，将并发度高的行锁向后放可以减轻影响。

死锁检测与恢复：innodb_lock_wait_timeout等待超时时间，一般为默认50秒；innodb_deadlock_detect Innodb中的死锁检测开关，一般为no。

数据库热点行设计：1、在后台使用中间件，限制一次性进入数据库中事务限制；2、将记录分为多行，多个记录均可进行操作，此时注意下限判断即可。
```

## 隔离
```
在默认Innodb引擎中，mvcc为可重复隔离级别，其中使用read-view一致性视图来保证一致性，每次进行select时均为快照读。但需要注意的是，在mvcc控制中，update时会先读再写（也就是先当前读后写入），可以读取最新的数据结果而不是快照结果；除此之外，加锁的select也可以进行当前读。在读提交环境下，视图是在执行语句时创建的。
```

## 数据库表的删除
### 整表删除
```
在Innodb中，默认命令innodb_file_per_table = no，当开启命令时，表都是存在文件中而不是共享空间中，此时使用drop table可以释放空间。
```
### 部分行删除
```
部分行删除时使用delete并不会释放空间，只是会对数据进行打删除标记。

  删除整个页：整个页进行删除标记，里边的数据能够被各种id不同的数据覆盖

  删除某页的部分行：新加入数据时要和原数据id一致才能覆盖。
```

### 数据空洞
```
  当我们进行DML时，页的分裂会产生页利用率不高，出现数据空洞问题。解决办法就是重建表：创建临时表 -> 原表B+树结构放入临时表（此时有更改则记入row log）-> 表名互换 -> row log日志回放在新表

  alter table A engine=InnoDB。默认ALGORITHM=inplace，也就是在引擎层进行临时表创建转移，ALGORITHM=copy则是在server层进行拷贝。online的DDL一定是inplace的，inplace不一定是online。

```


